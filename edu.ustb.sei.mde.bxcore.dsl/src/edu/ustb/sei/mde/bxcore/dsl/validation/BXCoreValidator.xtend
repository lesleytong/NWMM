/*
 * generated by Xtext 2.14.0
 */
package edu.ustb.sei.mde.bxcore.dsl.validation

import edu.ustb.sei.mde.bxcore.dsl.bXCore.BXCorePackage
import edu.ustb.sei.mde.bxcore.dsl.bXCore.BXFunctionDefinition
import edu.ustb.sei.mde.bxcore.dsl.bXCore.BXProgram
import edu.ustb.sei.mde.bxcore.dsl.bXCore.ContextAwareUnidirectionalAction
import edu.ustb.sei.mde.bxcore.dsl.bXCore.ModificationExpressionBlock
import edu.ustb.sei.mde.bxcore.dsl.bXCore.Pattern
import edu.ustb.sei.mde.bxcore.dsl.bXCore.PatternDefinition
import edu.ustb.sei.mde.bxcore.dsl.bXCore.PatternDefinitionReference
import edu.ustb.sei.mde.bxcore.dsl.bXCore.PatternTypeLiteral
import edu.ustb.sei.mde.bxcore.dsl.bXCore.TypeLiteral
import edu.ustb.sei.mde.bxcore.dsl.bXCore.TypeVar
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreContextSource
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreDeriveSource
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreExpandSource
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreExpandView
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreFork
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreFunctionCall
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreGraphReplace
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreIndex
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreStatement
import edu.ustb.sei.mde.bxcore.dsl.infer.InferData
import edu.ustb.sei.mde.bxcore.dsl.infer.InferManager
import edu.ustb.sei.mde.bxcore.dsl.infer.TypeInferenceException
import edu.ustb.sei.mde.bxcore.dsl.structure.TupleType
import edu.ustb.sei.mde.structure.Tuple2
import java.util.ArrayList
import java.util.HashMap
import java.util.List
import org.eclipse.emf.ecore.ENamedElement
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.xbase.XBlockExpression
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreDependencyView
import org.eclipse.xtext.xbase.XExpression
import edu.ustb.sei.mde.bxcore.dsl.bXCore.ModificationExpression

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class BXCoreValidator extends AbstractBXCoreValidator {

	@Check
	def checkBXProgram(BXProgram program) {
		try {
			InferManager.getInferredTypeModel(program.eResource);
		} catch (Exception e) {
			if(e instanceof TypeInferenceException) {
				if(e.reason!==program) {
					error(e.message, e.reason);				
				}
				else error(e.message, program, BXCorePackage.Literals.BX_PROGRAM__DEFINITIONS);
			} else error(e.message, program, BXCorePackage.Literals.BX_PROGRAM__DEFINITIONS);
			
		}
	}
	
	@Check
	def checkXmuCoreStatement(XmuCoreStatement stat) {
		val data = InferManager.safeGetInferredTypeModel(stat.eResource);
		if(stat.typeIndicator!==null && data!==null) {
			val inferredSource = data.sourceInfer.getType(stat);
			val definedSource = data.sourceInfer.getType(stat.typeIndicator.sourceType);
			if(inferredSource.compare(definedSource)===false) {
				warning('''The defined source type is different from the inferred type
				The inferred type is «inferredSource.text»''', stat);
			}
			
			val inferredView = data.viewInfer.getType(stat);
			val definedView = data.viewInfer.getType(stat.typeIndicator.viewType);
			if(inferredView.compare(definedView)===false) {
				warning('''The defined view type is different from the inferred type
				The inferred type is «inferredSource.text»''', stat);
			}
		}
		if(data!==null) stat.checkVarMappings(data);
	}
		
	def text(TupleType type) {
		'''(«FOR t:type.tuples SEPARATOR ','»«t.first»:«t.second.text»«IF t.third»[]«ENDIF»«ENDFOR»)'''
	}
		
	def text(Object object) {
		if(object instanceof ENamedElement) object.name
		else object.toString
	}
		
	def void checkVarMappings(XmuCoreStatement statement, InferData data) {
		if(statement instanceof XmuCoreExpandSource) {
			// checked by sovler
		} else if(statement instanceof XmuCoreExpandView) {
			// checked by sovler
		} else if(statement instanceof XmuCoreFork) {
			// checked by sovler
		} else if(statement instanceof XmuCoreGraphReplace) {
			val srcType = data.sourceInfer.getType(statement);
			val viwType = data.viewInfer.getType(statement);
			statement.conversions.forEach[c|
				if(c.source.exists[s|!srcType.tuples.exists[t|t.first.equals(s)]]) {
					error('undefined source variable', c);
				}
				if(c.view.exists[s|!viwType.tuples.exists[t|t.first.equals(s)]]) {
					error('undefined view variable', c);
				}
			];
		} else if(statement instanceof XmuCoreFunctionCall) {
			// checked by sovler
		} else if(statement instanceof XmuCoreIndex) {
			// checked by sovler
		}
	}
	
	@Check
	def checkBXFunction(BXFunctionDefinition func) {
		val data = InferManager.safeGetInferredTypeModel(func.eResource);
		if(func.typeIndicator!==null && data!==null) {
			val inferredSource = data.sourceInfer.getType(func);
			val definedSource = data.sourceInfer.getType(func.typeIndicator.sourceType);
			if(inferredSource.compare(definedSource)===false) {
				warning('''The defined source type is different from the inferred type
				The inferred type is «inferredSource.text»''', func);
			}
			
			val inferredView = data.viewInfer.getType(func);
			val definedView = data.viewInfer.getType(func.typeIndicator.viewType);
			if(inferredView.compare(definedView)===false) {
				warning('''The defined view type is different from the inferred type
				The inferred type is «inferredSource.text»''', func);
			}
		}
	}
	
	@Check
	def checkPattern(Pattern e) {
		val pat = if(e instanceof PatternTypeLiteral) e as PatternTypeLiteral else (e as PatternDefinitionReference).pattern.literal as PatternTypeLiteral;
		
		if(!pat.additional.empty) {
			val isSource = e.eContainingFeature.isSource
			val initializedVars = e.getVarsWithInitializer(isSource);
			if(!isSource) {
				e.eContainer.eAllContents.forEach[c|
					if(c instanceof XmuCoreDependencyView) {
						initializedVars.addAll(c.dependentType.elements);
					} // FIXME: not complete! due to var mappings
				];
			}
			
			val uninitialized = pat.additional.findFirst[f|f->initializedVars.findFirst[v|v.name.equals(f.name)]===null];
			
			if(uninitialized!==null) {
				warning('The additional variable may be uninitialized', uninitialized); // we ignore var mappings
			}
		}
	}
	
	def boolean isSource(EStructuralFeature contain) {
		if(contain === BXCorePackage.Literals.XMU_CORE_ALIGN__SOURCE_PATTERN
			|| contain === BXCorePackage.Literals.XMU_CORE_MATCH_SOURCE__PATTERN
			|| contain === BXCorePackage.Literals.XMU_CORE_EXPAND_SOURCE__PATTERN
			|| contain === BXCorePackage.Literals.XMU_CORE_FOR_EACH_MATCH_SOURCE__PATTERN
			|| contain === BXCorePackage.Literals.XMU_CORE_GRAPH_REPLACE__SOURCE
		) true
		else false
	}
		
	def List<TypeVar> getVarsWithInitializer(EObject e, boolean isSource) {
		if(e===null || e instanceof BXFunctionDefinition) return new ArrayList;
		
		val res = e.eContainer.getVarsWithInitializer(isSource);
		
		if(e instanceof XmuCoreContextSource && isSource===false) {
			res.addAll((e as XmuCoreContextSource).mappingView.elements);
		} else if(e instanceof XmuCoreDeriveSource && isSource){
			res.addAll((e as XmuCoreDeriveSource).derivedType.elements)
		} // do not handle var mappings
		
		return res;
	}
	
	def warning(String message, EObject obj) {
		if (obj.eContainingFeature.isMany) {
			val list = obj.eContainer.eGet(obj.eContainingFeature) as List<EObject>;
			warning(message, obj.eContainer, obj.eContainingFeature, list.indexOf(obj));
		} else
			warning(message, obj.eContainer, obj.eContainingFeature);
	}
	
	def error(String message, EObject obj) {
		if (obj.eContainingFeature.isMany) {
			val list = obj.eContainer.eGet(obj.eContainingFeature) as List<EObject>;
			error(message, obj.eContainer, obj.eContainingFeature, list.indexOf(obj));
		} else
			error(message, obj.eContainer, obj.eContainingFeature);
	}
	
	
	protected def groupTypeLiterals(BXProgram program) {
		val literals = program.eAllContents.filter[e|e instanceof TypeLiteral].map[return (it as TypeLiteral)->TupleType.make(it as TypeLiteral)].toList;
		val groups = literals.groupBy[it.value];
		val result = new HashMap;
		
		groups.forEach[k,v,id|
			val pair = Tuple2.make(k,id);
			v.forEach[p|result.put(p.key, pair);];
		];
		
		return result;
	}
	
	@Check
	def checkContextAwareUnidirectionalAction(XBlockExpression block) {
		block.expressions.filter[it instanceof ModificationExpressionBlock].forEach[b,id|
			if(id>0)
				error('More than one modification block in the context',b);
		];
		
	}
	
	override protected mustBeJavaStatementExpression(XExpression expr) {
		if(!(expr.eContainer instanceof ModificationExpression)) 
			super.mustBeJavaStatementExpression(expr)
	}
	
}
